// Generated by CoffeeScript 1.9.2
(function() {
  var Entity, EntityFunctions, Immutable, Model, Set, Transform, _,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  _ = require('lodash');

  Immutable = require('immutable');

  Set = require('../../util/Set');

  Model = require('../Model');

  Transform = require('../graphics/Transform');


  /*
  Entities are hierarchical graphical objects.
  
  Entity ::=
    id: String
    name: String | null
    transform: Transform
    child: Entity
   */

  Entity = (function(superClass) {
    extend(Entity, superClass);

    function Entity() {
      return Entity.__super__.constructor.apply(this, arguments);
    }

    return Entity;

  })(Model);

  EntityFunctions = {
    make: (function() {
      var _nextId, _spawnCount;
      _spawnCount = 0;
      _nextId = function() {
        return "entity-" + (_spawnCount++);
      };
      return function(name, transform, child, id) {
        var config, fields, initialData, r;
        config = {
          name: name,
          child: child,
          id: id
        };
        initialData = _.defaults({}, {
          transform: transform
        }, {
          transform: Transform["default"]
        });
        fields = _.defaults(config, {
          id: _nextId(),
          child: null,
          name: null,
          timelines: Immutable.List(),
          timelinesData: Immutable.Map(),
          localData: initialData,
          computedData: initialData
        });
        r = _.assign(new Entity(), fields);
        return r;
      };
    })(),
    getId: function(entity) {
      return entity.id;
    },
    getName: function(entity) {
      return entity.name;
    },
    getChild: function(entity) {
      return entity.child;
    },
    getLocalData: function(entity) {
      return entity.localData;
    },
    getComputedData: function(entity) {
      return entity.computedData;
    },
    getTimelineStack: function(entity) {
      return entity.timelines.toArray();
    },
    getProgressForTimeline: function(entity, timelineId) {
      return (entity.timelinesData.get(timelineId)).progress;
    },
    isAttachedToTimeline: function(entity, timelineId) {
      return entity.timelinesData.has(timelineId);
    },
    getTransform: function(entity) {
      return (EntityFunctions.getComputedData(entity)).transform;
    },
    getPosition: function(entity) {
      return Transform.getPosition(EntityFunctions.getTransform(entity));
    },
    getRotation: function(entity) {
      return Transform.getRotation(EntityFunctions.getTransform(entity));
    },
    getScale: function(entity) {
      return Transform.getScale(EntityFunctions.getTransform(entity));
    },
    setChild: function(entity, child) {
      return _.assign({}, entity, {
        child: child
      });
    },
    removeChild: function(entity) {
      return _.assign({}, entity, {
        child: null
      });
    },
    setLocalData: function(entity, localData) {
      return _.assign({}, entity, {
        localData: localData
      });
    },
    setComputedData: function(entity, computedData) {
      return _.assign({}, entity, {
        computedData: computedData
      });
    },
    insertTimeline: function(entity, timelineId, progress, stackPosition) {
      if (progress == null) {
        progress = 0;
      }
      if (stackPosition == null) {
        stackPosition = 0;
      }
      return _.assign({}, entity, {
        timelines: entity.timelines.splice(stackPosition, 0, timelineId),
        timelinesData: entity.timelinesData.set(timelineId, {
          progress: progress
        })
      });
    },
    removeTimeline: function(entity, timelineIdx) {
      var timelineId;
      timelineId = entity.timelines.get(timelineIdx);
      if (timelineId != null) {
        return _.assign({}, entity, {
          timelines: entity.timelines["delete"](timelineIdx),
          timelinesData: entity.timelinesData["delete"](timelineId)
        });
      } else {
        return entity;
      }
    },
    progressTimeline: function(entity, timelineId, delta) {
      return _.assign({}, entity, {
        timelinesData: entity.timelinesData.update(timelineId, function(timelineData) {
          return _.assign({}, timelineData, {
            progress: timelineData.progress + delta
          });
        })
      });
    },
    setTransform: function(entity, transform) {
      var newLocaldata;
      newLocaldata = _.assign(EntityFunctions.getLocalData(entity), {
        transform: transform
      });
      return EntityFunctions.setLocalData(entity, newLocaldata);
    },
    transform: function(entity, arg) {
      var rotate, scale, translate;
      translate = arg.translate, rotate = arg.rotate, scale = arg.scale;
      if (translate != null) {
        EntityFunctions.translate(entity, translate);
      }
      if (rotate != null) {
        EntityFunctions.rotate(entity, rotate);
      }
      if (scale != null) {
        return EntityFunctions.scale(entity, scale);
      }
    },
    translate: function(entity, amount) {
      return _.assign({}, entity, {
        transform: Transform.translate(EntityFunctions.getTransform(entity), amount)
      });
    },
    rotate: function(entity, amount) {
      return _.assign({}, entity, {
        transform: Transform.rotate(EntityFunctions.getTransform(entity), amount)
      });
    },
    scale: function(entity, amount) {
      return _.assign({}, entity, {
        transform: Transform.scale(EntityFunctions.getTransform(entity), amount)
      });
    }
  };

  module.exports = EntityFunctions;

}).call(this);

//# sourceMappingURL=Entity.js.map
