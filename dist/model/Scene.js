// Generated by CoffeeScript 1.9.2
(function() {
  var Entity, Model, Scene, Set, _, createStore, darko, u,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  _ = require('lodash');

  u = require('updeep');

  createStore = require('redux').createStore;

  darko = require('darko');

  Model = require('./Model');

  Entity = require('./entities/Entity');

  Set = require('../util/Set');


  /*
  The main state of an interactive scene.
  
  Scene ::=
     * Entity database, mapping entity unique IDs to model.
    entities: { String -> Entity }
   */

  Scene = (function(superClass) {
    extend(Scene, superClass);

    function Scene() {
      return Scene.__super__.constructor.apply(this, arguments);
    }

    Scene.make = function(entities, timelines) {
      return _.assign(new Scene(), {
        entities: entities,
        timelines: timelines,
        darko: null
      });
    };

    Scene["with"] = function(entitiesArray, timelineArray) {
      if (entitiesArray == null) {
        entitiesArray = [];
      }
      if (timelineArray == null) {
        timelineArray = [];
      }
      return Scene.make(entitiesArray.reduce(Set.put, Set.withHashProperty('id')), timelineArray.reduce(Set.put, Set.withHashProperty('id')));
    };

    Scene.empty = Object.freeze(Scene.make(Set.withHashProperty('id'), Set.withHashProperty('id')));

    Scene.getEntity = function(scene, entityId) {
      return Set.get(scene.entities, entityId);
    };

    Scene.getEntityById = Scene.getEntity;

    Scene.getEntityByName = function(scene, entityName) {
      return Set.find(scene.entities, {
        name: entityName
      });
    };

    Scene.getAllEntityIds = function(scene) {
      return Object.keys(Set.asObject(scene.entities));
    };

    Scene.getAllEntities = function(scene) {
      return Set.asArray(scene.entities);
    };

    Scene.getTimelineById = function(scene, timelineId) {
      return Set.get(scene.timelines, timelineId);
    };

    Scene.getAllTimelines = function(scene) {
      return Set.asArray(scene.timelines);
    };

    Scene.addEntity = function(scene, entity) {
      return _.assign({}, scene, {
        entities: Set.put(scene.entities, entity)
      });
    };

    Scene.removeEntity = function(scene, entityId) {
      return _.assign({}, scene, {
        entities: Set.remove(scene.entities, Set.get(scene.entities, entityId))
      });
    };

    Scene.linkEntitiesById = function(scene, parentId, childId) {
      var child, newScene, offendingIds, parent;
      parent = Scene.getEntity(scene, parentId);
      child = Scene.getEntity(scene, childId);
      if ((parent != null) && (child != null)) {
        newScene = scene;
        newScene = Scene.mutateEntity(newScene, parent.id, function(e) {
          return Entity.setChild(e, child);
        });
        return newScene;
      } else {
        offendingIds = parent != null ? [childId] : child != null ? [parentId] : [parentId, childId];
        if (offendingIds.length === 1) {
          throw new Error("Attempted to link invalid entities " + parentId + " -> " + childId + ".\n(" + offendingIds[0] + " does not exist.)");
        } else {
          throw new Error("Attempted to link invalid entities " + parentId + " -> " + childId + ".\n(Neither exists.)");
        }
      }
    };


    /*
    Mutates an entity in a provided callback.
    
      scene [Scene] - the invoking `Scene`
      entityId [String] - the id of the entity to be modified
      proc [Function<Entity, Entity>] - procedure which takes in the specified
        `Entity` and returns a modified copy of the `Entity`. this procedure is
        not called if no `Entity` with ID `entityId` exists in this `Scene`.
     */

    Scene.mutateEntity = function(scene, entityId, proc) {
      var entity;
      entity = Scene.getEntity(scene, entityId);
      if (entity != null) {
        return _.assign({}, scene, {
          entities: Set.put(scene.entities, proc(entity))
        });
      } else {
        return scene;
      }
    };

    Scene.addTimeline = function(scene, timeline) {
      return _.assign({}, scene, {
        timelines: Set.put(scene.timelines, timeline)
      });
    };

    Scene.removeTimelineById = function(scene, timelineId) {
      var toRemove;
      toRemove = Set.get(scene.timelines, timelineId);
      return _.assign({}, scene, {
        timelines: Set.remove(scene.timelines, toRemove)
      });
    };

    Scene.attachEntityToTimeline = function(scene, entityId, timelineId, initialProgress) {
      if (initialProgress == null) {
        initialProgress = 0;
      }
    };

    Scene.mutateTimeline = function(scene, timelineId, proc) {
      var timeline;
      timeline = Scene.getTimelineById(scene, timelineId);
      if (timeline != null) {
        return _.assign({}, scene, {
          timelines: Set.put(scene.timelines, proc(timeline))
        });
      } else {
        return scene;
      }
    };

    return Scene;

  })(Model);

  module.exports = Scene;

}).call(this);

//# sourceMappingURL=Scene.js.map
