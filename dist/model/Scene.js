// Generated by CoffeeScript 1.9.2
(function() {
  var Entity, Model, Scene, Set, _, createStore, u,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  _ = require('lodash');

  u = require('updeep');

  createStore = require('redux').createStore;

  Model = require('./Model');

  Entity = require('./entities/Entity');

  Set = require('../util/Set');


  /*
  The main state of an interactive scene.
  
  Scene ::=
     * Entity database, mapping entity unique IDs to model.
    entities: { String -> Entity }
   */

  Scene = (function(superClass) {
    extend(Scene, superClass);

    function Scene() {
      return Scene.__super__.constructor.apply(this, arguments);
    }

    Scene.make = function(entities, timelines) {
      return _.assign(new Scene(), {
        entities: entities,
        timelines: timelines
      });
    };

    Scene["with"] = function(entitiesArray, timelineArray) {
      if (entitiesArray == null) {
        entitiesArray = [];
      }
      if (timelineArray == null) {
        timelineArray = [];
      }
      return Scene.make(entitiesArray.reduce(Set.put, Set.withHashProperty('id')), timelineArray.reduce(Set.put, Set.withHashProperty('id')));
    };

    Scene.empty = Object.freeze(Scene.make(Set.withHashProperty('id'), Set.withHashProperty('id')));

    Scene.getEntity = function(scene, entityId) {
      return Set.get(scene.entities, entityId);
    };

    Scene.getEntityById = Scene.getEntity;

    Scene.getEntityByName = function(scene, entityName) {
      return Set.find(scene.entities, {
        name: entityName
      });
    };

    Scene.getAllEntityIds = function(scene) {
      return Object.keys(Set.asObject(scene.entities));
    };

    Scene.getAllEntities = function(scene) {
      return Set.asArray(scene.entities);
    };

    Scene.getTimelineById = function(scene, timelineId) {
      return Set.get(scene.timelines, timelineId);
    };

    Scene.getTimeline = Scene.getTimelineById;

    Scene.getAllTimelines = function(scene) {
      return Set.asArray(scene.timelines);
    };

    Scene.addEntity = function(scene, entity) {
      return _.assign({}, scene, {
        entities: Set.put(scene.entities, entity)
      });
    };

    Scene.removeEntity = function(scene, entityId) {
      return _.assign({}, scene, {
        entities: Set.remove(scene.entities, Set.get(scene.entities, entityId))
      });
    };

    Scene.linkEntitiesById = function(scene, parentId, childId) {
      var child, newScene, offendingIds, parent;
      parent = Scene.getEntity(scene, parentId);
      child = Scene.getEntity(scene, childId);
      if ((parent != null) && (child != null)) {
        newScene = scene;
        newScene = Scene.mutateEntity(newScene, parent.id, function(e) {
          return Entity.setChild(e, child);
        });
        return newScene;
      } else {
        offendingIds = parent != null ? [childId] : child != null ? [parentId] : [parentId, childId];
        if (offendingIds.length === 1) {
          throw new Error("Attempted to link invalid entities " + parentId + " -> " + childId + ".\n(" + offendingIds[0] + " does not exist.)");
        } else {
          throw new Error("Attempted to link invalid entities " + parentId + " -> " + childId + ".\n(Neither exists.)");
        }
      }
    };


    /*
    Mutates an entity in a provided callback.
    
      scene [Scene] - the invoking `Scene`
      entityId [String] - the id of the entity to be modified
      proc [Function<Entity, Entity>] - procedure which takes in the specified
        `Entity` and returns a modified copy of the `Entity`. this procedure is
        not called if no `Entity` with ID `entityId` exists in this `Scene`.
     */

    Scene.mutateEntity = function(scene, entityId, proc) {
      var entity;
      entity = Scene.getEntity(scene, entityId);
      if (entity != null) {
        return _.assign({}, scene, {
          entities: Set.put(scene.entities, proc(entity))
        });
      } else {
        return scene;
      }
    };

    Scene.addTimeline = function(scene, timeline) {
      return _.assign({}, scene, {
        timelines: Set.put(scene.timelines, timeline)
      });
    };

    Scene.removeTimelineById = function(scene, timelineId) {
      var toRemove;
      toRemove = Set.get(scene.timelines, timelineId);
      return _.assign({}, scene, {
        timelines: Set.remove(scene.timelines, toRemove)
      });
    };

    Scene.attachEntityToTimeline = function(scene, entityId, timelineId, progress, stackPosition) {
      var entity, timeline;
      if (progress == null) {
        progress = 0;
      }
      if (stackPosition == null) {
        stackPosition = 0;
      }
      entity = Scene.getEntity(scene, entityId);
      timeline = Scene.getTimeline(scene, timelineId);
      if ((entity != null) && (timeline != null)) {
        return Scene.mutateEntity(scene, entityId, function(e) {
          return Entity.insertTimeline(e, timelineId, progress, stackPosition);
        });
      } else {
        return scene;
      }
    };

    Scene.detachEntityFromTimelineAtIndex = function(scene, entityId, timelineIdx) {
      return Scene.mutateEntity(scene, entityId, function(e) {
        return Entity.removeTimeline(e, timelineIdx);
      });
    };

    Scene.updateEntityData = function(scene, entityId) {
      return Scene.mutateEntity(scene, entityId, function(entity) {
        return Scene.Entities.computeEntityData(scene, entity);
      });
    };

    Scene.mutateTimeline = function(scene, timelineId, proc) {
      var timeline;
      timeline = Scene.getTimelineById(scene, timelineId);
      if (timeline != null) {
        return _.assign({}, scene, {
          timelines: Set.put(scene.timelines, proc(timeline))
        });
      } else {
        return scene;
      }
    };


    /*
    Entity methods
    
    These functions operate on and return entities, but necessitate knowledge of
      the scene. They are thus all "semi-curried" - given a single argument, the
      scene context, they each produce a function which awaits the rest of the
      arguments, and operates over the provided scene as context.
    (Implied with this is that these functions do not mutate anything outside of
      the specified entity.)
    
    fn(scene, a, b, c) == fn(scene)(a, b, c)
     */

    Scene.Entities = {
      computeEntityData: function(scene, entity) {
        var ctx;
        ctx = function(ent) {
          return Entity.setComputedData(ent, Entity.getTimelineStack(ent).map(function(timelineId) {
            var progress, timeline;
            timeline = Scene.getTimeline(scene, timelineId);
            progress = Entity.getProgressForTimeline(entity, timelineId);
            return function(d) {
              return Timelines.mapping(timeline, progress, d);
            };
          }).reduce((function(data, mutator) {
            return mutator(data);
          }), Entity.getLocalData(ent)));
        };
        if (arguments.length === 1) {
          return ctx;
        } else {
          return ctx.apply(null, _.tail(arguments));
        }
      },
      mutateLocalData: function(scene, entity, mutator) {
        var ctx;
        ctx = function(ent, mutator) {
          ent = Entity.setLocalData(ent, mutator(Entity.getLocalData(ent)));
          return ent = Scene.Entities.computeEntityData(scene, ent);
        };
        if (arguments.length === 1) {
          return ctx;
        } else {
          return ctx.apply(null, _.tail(arguments));
        }
      }
    };

    return Scene;

  })(Model);

  module.exports = Scene;

}).call(this);

//# sourceMappingURL=Scene.js.map
