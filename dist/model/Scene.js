// Generated by CoffeeScript 1.9.2
(function() {
  var Entity, Lens, Model, Scene, Set, Timeline, TimelinesTable, _, clamp,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  _ = require('lodash');

  Lens = require('lens');

  Model = require('./Model');

  Entity = require('./entities/Entity');

  Timeline = require('./timelines/Timeline');

  TimelinesTable = require('./timelines/TimelinesTable');

  Set = require('../util/Set');

  clamp = require('../util/clamp');


  /*
  The main state of an interactive scene.
  
  Scene ::=
     * Entity database, mapping entity unique IDs to model.
    entities: { String -> Entity }
   */

  Scene = (function(superClass) {
    extend(Scene, superClass);

    function Scene() {
      return Scene.__super__.constructor.apply(this, arguments);
    }

    Scene.make = function(entities, timelines) {
      return _.assign(new Scene(), {
        entities: entities,
        timelines: timelines
      });
    };

    Scene["with"] = function(entitiesArray, timelineArray) {
      if (entitiesArray == null) {
        entitiesArray = [];
      }
      if (timelineArray == null) {
        timelineArray = [];
      }
      return Scene.make(entitiesArray.reduce(Set.put, Set.withHashProperty('id')), timelineArray.reduce(Set.put, Set.withHashProperty('id')));
    };

    Scene.empty = Object.freeze(Scene.make(Set.withHashFunction(Entity.id.get), Set.withHashFunction(Timeline.id.get)));


    /* Lenses */

    Scene.entitySet = Lens.fromPath('entities');

    Scene.allEntities = Lens.compose(Scene.entitySet, Set.asArray);

    Scene.entity = (function() {
      var composed;
      composed = Lens.compose(Scene.entitySet, Set.element);
      return new Lens(function(scene, id) {
        return composed.get(scene, [], [id]);
      }, function(scene, id, v) {
        return composed.set(scene, [], [id], v);
      });
    })();

    Scene.entityByName = new Lens(function(scene, name) {
      return Set.find(Scene.entitySet.get(scene), {
        name: name
      });
    }, function(scene, name, v) {
      var id;
      id = Entity.id.get(Set.find(Scene.entitySet.get(scene), {
        name: name
      }));
      return Scene.entity.over(scene, id, function(e) {
        return v;
      });
    });

    Scene.timelineSet = Lens.fromPath('timelines');

    Scene.allTimelines = Lens.compose(Scene.timelineSet, Set.asArray);

    Scene.timeline = (function() {
      var composed;
      composed = Lens.compose(Scene.timelineSet, Set.element);
      return new Lens(function(scene, id) {
        return composed.get(scene, [], [id]);
      }, function(scene, id, v) {
        return composed.set(scene, [], [id], v);
      });
    })();

    Scene.getAllEntityIds = function(scene) {
      return Set.keys(scene.entities);
    };

    Scene.addEntity = function(scene, entity) {
      return _.assign({}, scene, {
        entities: Set.put(scene.entities, entity)
      });
    };

    Scene.removeEntity = function(scene, entityId) {
      return _.assign({}, scene, {
        entities: Set.remove(scene.entities, Set.get(scene.entities, entityId))
      });
    };

    Scene.linkEntitiesById = function(scene, parentId, childId) {
      var child, newScene, offendingIds, parent;
      parent = Scene.entity.get(scene, parentId);
      child = Scene.entity.get(scene, childId);
      if ((parent != null) && (child != null)) {
        newScene = scene;
        newScene = Scene.entity.over(newScene, parent.id, function(e) {
          return Entity.child.set(e, child);
        });
        return newScene;
      } else {
        offendingIds = parent != null ? [childId] : child != null ? [parentId] : [parentId, childId];
        if (offendingIds.length === 1) {
          throw new Error("Attempted to link invalid entities " + parentId + " -> " + childId + ".\n(" + offendingIds[0] + " does not exist.)");
        } else {
          throw new Error("Attempted to link invalid entities " + parentId + " -> " + childId + ".\n(Neither exists.)");
        }
      }
    };

    Scene.addTimeline = function(scene, timeline) {
      return _.assign({}, scene, {
        timelines: Set.put(scene.timelines, timeline)
      });
    };

    Scene.removeTimelineById = function(scene, timelineId) {
      var toRemove;
      toRemove = Set.get(scene.timelines, timelineId);
      return _.assign({}, scene, {
        timelines: Set.remove(scene.timelines, toRemove)
      });
    };

    Scene.attachEntityToTimeline = function(scene, entityId, timelineId, progress, stackPosition) {
      var entity, timeline;
      if (progress == null) {
        progress = 0;
      }
      if (stackPosition == null) {
        stackPosition = 0;
      }
      entity = Scene.entity.get(scene, entityId);
      timeline = Scene.timeline.get(scene, timelineId);
      if ((entity != null) && (timeline != null)) {
        return Scene.entity.over(scene, entityId, function(e) {
          return Entity.insertTimeline(e, timelineId, progress, stackPosition);
        });
      } else {
        return scene;
      }
    };

    Scene.detachEntityFromTimelineAtIndex = function(scene, entityId, timelineIdx) {
      return Scene.entity.over(scene, entityId, function(e) {
        return Entity.removeTimeline(e, timelineIdx);
      });
    };

    Scene.updateEntityData = function(scene, entityId) {
      return Scene.entity.over(scene, entityId, function(entity) {
        return Scene.Entities.computeEntityData(scene, entity);
      });
    };

    Scene.progressTimeline = function(scene, timelineId, delta) {
      var affectedEntityIds, progressEntity, scaledDelta, sceneWithUpdatedProgress, timelineObj;
      timelineObj = Scene.timeline.get(scene, timelineId);
      scaledDelta = delta / Timeline.length.get(timelineObj);
      progressEntity = function(s, eId) {
        return Scene.entity.over(s, eId, function(e) {
          var currentProgress, newProgress;
          currentProgress = Entity.progressForTimeline.get(e, timelineId);
          newProgress = clamp(0, 1, currentProgress + scaledDelta);
          return Entity.progressForTimeline.set(e, timelineId, newProgress);
        });
      };
      affectedEntityIds = Scene.allEntities.get(scene).filter(function(entity) {
        return Entity.isAttachedToTimeline(entity, timelineId);
      }).map(function(entity) {
        return Entity.id.get(entity);
      });
      sceneWithUpdatedProgress = affectedEntityIds.reduce(progressEntity, scene);
      return affectedEntityIds.reduce(Scene.updateEntityData, sceneWithUpdatedProgress);
    };


    /*
    Entity methods
    
    These functions operate on and return entities, but necessitate knowledge of
      the scene. They are thus all "semi-curried" - given a single argument, the
      scene context, they each produce a function which awaits the rest of the
      arguments, and operates over the provided scene as context.
    (Implied with this is that these functions do not mutate anything outside of
      the specified entity.)
    
    fn(scene, a, b, c) == fn(scene)(a, b, c)
     */

    Scene.Entities = {
      computeEntityData: function(scene, entity) {
        var ctx;
        ctx = function(ent) {
          return Entity.computedData.set(ent, Entity.timelineStack.get(ent).map(function(timelineId) {
            var progress, timeline;
            timeline = Scene.timeline.get(scene, timelineId);
            progress = Entity.progressForTimeline.get(entity, timelineId);
            return function(d) {
              return TimelinesTable.mapping(timeline, progress, d);
            };
          }).reduce((function(data, mutator) {
            return mutator(data);
          }), Entity.localData.get(ent)));
        };
        if (arguments.length === 1) {
          return ctx;
        } else {
          return ctx.apply(null, _.tail(arguments));
        }
      },
      mutateLocalData: function(scene, entity, mutator) {
        var ctx;
        ctx = function(ent, mutator) {
          return Scene.Entities.computeEntityData(scene, Entity.localData.over(ent, mutator));
        };
        if (arguments.length === 1) {
          return ctx;
        } else {
          return ctx.apply(null, _.tail(arguments));
        }
      }
    };

    return Scene;

  })(Model);

  module.exports = Scene;

}).call(this);

//# sourceMappingURL=Scene.js.map
