// Generated by CoffeeScript 1.9.2
(function() {
  var Model, Path, Vector2, _, calculateLength, ooChain, pairs,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  _ = require('lodash');

  Model = require('../Model');

  Vector2 = require('./Vector2');

  ooChain = require('../../util/ooChain');

  pairs = require('../../util/pairs');

  calculateLength = function(points) {
    return pairs(points).map(function(arg) {
      var dst, src;
      src = arg[0], dst = arg[1];
      return Vector2.subtract(dst, src);
    }).reduce(_.add, 0);
  };


  /*
  Describes an ordered path of points.
  
  Path ::=
     * The origin of this path's local coordinate system.
    position: Vector2
  
     * The points comprising this path, relative to `position`.
    points: [Vector2]
  
     * The length of the polyline connecting all points.
    length: Number
   */

  Path = (function(superClass) {
    extend(Path, superClass);

    function Path() {
      return Path.__super__.constructor.apply(this, arguments);
    }

    Path.make = function(position, points) {
      if (position == null) {
        position = Vector2.zero;
      }
      if (points == null) {
        points = [];
      }
      return _.assign(new Path(), {
        position: position,
        points: points,
        length: calculateLength(points)
      });
    };

    Path.empty = Object.freeze(Path.make());

    Path.start = function(path) {
      return _.head(path.points);
    };

    Path.start = function(path) {
      return _.last(path.points);
    };

    Path.checkCollision = function(pathA, pathB) {};


    /*
    Calculates the point at the given position on the path.
    
      path: the invoking `Path`.
      position: a float between 0 and 1; the position along the path.
     */

    Path.pointAt = function(path, position) {
      var dist, dst, i, len, moved, ref, scaledPosition, segments, src, targetSegment;
      scaledPosition = path.length * position;
      segments = pairs(path.points);
      moved = 0;
      targetSegment = null;
      for (i = 0, len = segments.length; i < len; i++) {
        ref = segments[i], src = ref[0], dst = ref[1];
        dist = Vector2.subtract(dst, src);
        if (moved + dist > scaledPosition) {
          targetSegment = [src, dst];
          break;
        } else {
          moved += dist;
        }
      }
      if (targetSegment != null) {
        src = targetSegment[0], dst = targetSegment[1];
        return ooChain(dst).then(Vector2.subtract, src).then(Vector2.scale, position - moved).then(Vector2.add, src).value();
      } else {
        return Path.end(path);
      }
    };

    Path.addPoint = function(path, point) {
      return _.assign({}, path, {
        points: slice.call(path.points).concat([point])
      });
    };

    return Path;

  })(Model);

  module.exports = Path;

}).call(this);

//# sourceMappingURL=Path.js.map
