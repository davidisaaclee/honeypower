// Generated by CoffeeScript 1.9.2
(function() {
  var Lens, Model, Path, Vector2, _, calculateLength, ooChain, pairs,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  _ = require('lodash');

  Lens = require('Lens');

  Model = require('../Model');

  Vector2 = require('./Vector2');

  ooChain = require('../../util/ooChain');

  pairs = require('../../util/pairs');

  calculateLength = function(points) {
    return pairs(points).map(function(arg) {
      var dst, src;
      src = arg[0], dst = arg[1];
      return Vector2.subtract(dst, src);
    }).map(function(displacement) {
      return Vector2.magnitude.get(displacement);
    }).reduce(_.add, 0);
  };


  /*
  Describes an ordered path of points.
  
  Path ::=
     * The origin of this path's local coordinate system.
    position: Vector2
  
     * The points comprising this path, relative to `position`.
    points: [Vector2]
  
     * The length of the polyline connecting all points.
    length: Number
   */

  Path = (function(superClass) {
    extend(Path, superClass);

    function Path() {
      return Path.__super__.constructor.apply(this, arguments);
    }

    Path.make = function() {
      var args;
      args = (function() {
        switch (false) {
          case !(arguments.length >= 2):
            return {
              position: arguments[0],
              points: arguments[1]
            };
          case arguments.length !== 1:
            return {
              points: arguments[0]
            };
          default:
            return {};
        }
      }).apply(this, arguments);
      args = _.defaults(args, {
        position: Vector2.zero,
        points: []
      });
      return _.assign(new Path(), {
        position: args.position,
        points: args.points,
        length: calculateLength(args.points)
      });
    };

    Path.empty = Object.freeze(Path.make());

    Path.point = Lens.fromPath(function(idx) {
      return ['points', idx];
    });

    Path.start = Lens.fromPath('points.0');

    Path.end = new Lens(function(path) {
      return _.last(path.points);
    }, function(path, v) {
      return slice.call(_.initial(path.points)).concat([v]);
    });


    /*
    Calculates the point at the given position on the path.
    
      path: the invoking `Path`.
      position: a float between 0 and 1; the position along the path.
     */

    Path.pointAt = function(path, position) {
      var distanceLeft, dst, segments, src, targetSegment;
      distanceLeft = path.length * position;
      segments = pairs(path.points);
      targetSegment = _.find(segments, function(arg) {
        var dist, dst, nextDistanceLeft, src;
        src = arg[0], dst = arg[1];
        dist = Vector2.magnitude.get(Vector2.subtract(dst, src));
        nextDistanceLeft = distanceLeft - dist;
        if (nextDistanceLeft < 0) {
          return true;
        } else {
          distanceLeft = nextDistanceLeft;
          return false;
        }
      });
      if (targetSegment != null) {
        src = targetSegment[0], dst = targetSegment[1];
        return ooChain(dst).then(Vector2.subtract, src).then(Vector2.magnitude.set, distanceLeft).then(Vector2.add, src).value();
      } else {
        return Path.end.get(path);
      }
    };

    Path.addPoint = function(path, point) {
      return _.assign({}, path, {
        points: slice.call(path.points).concat([point])
      });
    };

    return Path;

  })(Model);

  module.exports = Path;

}).call(this);

//# sourceMappingURL=Path.js.map
